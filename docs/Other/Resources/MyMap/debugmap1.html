<!DOCTYPE html>
<html>
  <head>
    <title>DEBUG Track Layout Renderer</title>
    <style>
      body {
        width: 100vw;
        height: 100vh;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: black;
      }
      .options {
        background-color: white;
        position: absolute;
        left: 0;
        bottom: 0;
      }
      button {
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <canvas id="railCanvas"></canvas>
    <div class="options">
      <button onclick="copyX()">=X</button>
      <button onclick="copyY()">=Y</button>
      <button onclick="plusX()">+X</button>
      <button onclick="minusX()">-X</button>
      <button onclick="plusY()">+Y</button>
      <button onclick="minusY()">-Y</button>
    </div>

    <script>
      async function main() {
        let res = await fetch("data.json");
        /** @typedef {object} RailData
         * @property {object[]} stations
         * @property {string} stations.id
         * @property {object} stations.location
         * @property {number} stations.location.x
         * @property {number} stations.location.y
         * @property {string} stations.name
         * @property {object} metadata
         * @property {string} metadata.version
         * @property {string} metadata.coordinateSystem
         * @property {number} metadata.scale
         * @property {object[]} tracks
         * @property {string} tracks.id
         * @property {string} tracks.name
         * @property {object[]} tracks.blocks
         * @property {string} tracks.blocks.blockId
         * @property {string} tracks.blocks.direction
         * @property {object[]} tracks.blocks.geometry
         * @property {number} tracks.blocks.geometry.x
         * @property {number} tracks.blocks.geometry.y
         */
        /** @type {RailData} */
        let data = await res.json();

        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById("railCanvas");
        canvas.width = document.body.getBoundingClientRect().width;
        canvas.height = document.body.getBoundingClientRect().height;
        /** @type {CanvasRenderingContext2D} */
        const ctx = canvas.getContext("2d");

        const scaleFactor = 2; // Adjust based on your coordinate scale

        /** @typedef {object} DBPoint
         * @property {number} x
         * @property {number} y
         * @property {number} trackIndex
         * @property {number} blockIndex
         * @property {number} pointIndex
         * @property {string} color
         */
        /** @type {DBPoint[]} */
        let db_points = [];

        /** @typedef {DBSelector}
         * @property {number} t
         * @property {number} b
         * @property {number} p
         */
        /** @type {DBSelector[]} */
        let selected_db = [];

        data.tracks.forEach((track, trackIndex) => {
          let prevX = Number.NEGATIVE_INFINITY;
          let prevY = Number.NEGATIVE_INFINITY;

          track.blocks.forEach((block, blockIndex) => {
            block.geometry.forEach((point, pointIndex) => {
              if (
                (Math.abs(point.y - prevY) >= 0.01 &&
                  Math.abs(point.y - prevY) / Math.abs(point.x - prevX) <=
                    0.3) ||
                Math.abs(point.y - prevY) <= 2
              )
                point.y = prevY;
              if (
                (Math.abs(point.x - prevX) >= 0.01 &&
                  Math.abs(point.x - prevX) / Math.abs(point.y - prevY) <=
                    0.3) ||
                Math.abs(point.x - prevX) <= 2
              )
                point.x = prevX;
              prevY = point.y;
              prevX = point.x;

              db_points.push({
                trackIndex,
                blockIndex,
                pointIndex,
                ...point,
                color: `hsl(${trackIndex * 50}, 100%, 50%)`,
              });
            });
          });
        });

        /** @param {RailData} data */
        function renderTracks(data) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          // ctx.fillStyle = "#000";
          // ctx.fillRect(0, 0, canvas.width, canvas.height);

          data.tracks.forEach((track, trackIndex) => {
            track.blocks.forEach((block) => {
              ctx.beginPath();
              // ctx.strokeStyle = `hsl(${trackIndex * 30}, 100%, 50%)`; // Different color per track
              ctx.strokeStyle = "#FF0000";
              if (/^[A-Z]{3}P\d+$/.test(block.blockId))
                ctx.strokeStyle = "#0000FF";
              ctx.lineWidth = 4 / viewport.scale;
              block.geometry.forEach((point, pointIndex) => {
                const x = point.x * scaleFactor;
                const y = point.y * scaleFactor;

                if (pointIndex === 0) {
                  ctx.moveTo(x, y);
                } else {
                  ctx.lineTo(x, y);
                }
              });

              ctx.stroke();
            });
          });
          data.tracks.forEach((v) => {
            let prevX = Number.NEGATIVE_INFINITY;
            let prevY = Number.NEGATIVE_INFINITY;

            v.blocks.forEach((block) => {
              // Draw block ID labels
              const firstPoint = block.geometry[0];
              ctx.fillStyle = "#FFF";
              let fontSize = Math.min(30 / viewport.scale, 12);
              ctx.font = fontSize + "px Arial";
              ctx.fillText(
                block.blockId,
                firstPoint.x * scaleFactor + 5,
                firstPoint.y * scaleFactor + fontSize / 2
              );
            });
          });
          db_points.forEach((v) => {
            // ctx.fillStyle = v.color;
            ctx.fillStyle = "#77F";
            let pixelSize = 1 * scaleFactor;
            let i = 0;
            for (let j of selected_db) {
              if (
                v.blockIndex == j.b &&
                v.pointIndex == j.p &&
                v.trackIndex == j.t
              ) {
                ctx.fillStyle = i == 0 ? "#ff6200" : "#0F0";
                pixelSize = 1.5 * scaleFactor;
                break;
              }
              i++;
            }
            let { x, y } =
              data.tracks[v.trackIndex].blocks[v.blockIndex].geometry[
                v.pointIndex
              ];
            ctx.fillRect(
              x * scaleFactor - pixelSize,
              y * scaleFactor - pixelSize,
              2 * pixelSize,
              2 * pixelSize
            );
          });

          data.stations.forEach((s) => {
            let { x, y } = s.location;
            x *= scaleFactor;
            y *= scaleFactor;
            ctx.fillStyle = "#FFF";
            let fontSize = 15 * scaleFactor;
            ctx.font = fontSize + "px Arial";
            ctx.fillText(
              s.name,
              x - ctx.measureText(s.name).width / 2,
              y + fontSize / 2 - fontSize / 4
            );
            ctx.font = fontSize / 2 + "px Arial";
            ctx.fillText(
              s.id,
              x - ctx.measureText(s.id).width / 2,
              y + fontSize
            );
          });
        }

        window.copyX = () => {
          data.tracks[selected_db[1].t].blocks[selected_db[1].b].geometry[
            selected_db[1].p
          ].x =
            data.tracks[selected_db[0].t].blocks[selected_db[0].b].geometry[
              selected_db[0].p
            ].x;
          redraw();
        };
        window.copyY = () => {
          data.tracks[selected_db[1].t].blocks[selected_db[1].b].geometry[
            selected_db[1].p
          ].y =
            data.tracks[selected_db[0].t].blocks[selected_db[0].b].geometry[
              selected_db[0].p
            ].y;
          redraw();
        };
        window.plusX = () => {
          let i = selected_db.length - 1;
          data.tracks[selected_db[i].t].blocks[selected_db[i].b].geometry[
            selected_db[i].p
          ].x++;
          redraw();
        };
        window.minusX = () => {
          let i = selected_db.length - 1;
          data.tracks[selected_db[i].t].blocks[selected_db[i].b].geometry[
            selected_db[i].p
          ].x--;
          redraw();
        };
        window.plusY = () => {
          let i = selected_db.length - 1;
          data.tracks[selected_db[i].t].blocks[selected_db[i].b].geometry[
            selected_db[i].p
          ].y++;
          redraw();
        };
        window.minusY = () => {
          let i = selected_db.length - 1;
          data.tracks[selected_db[i].t].blocks[selected_db[i].b].geometry[
            selected_db[i].p
          ].y--;
          redraw();
        };

        // Add viewport transformations
        window.viewport = {
          x: 0,
          y: -400,
          scale: 1,
        };

        // Mouse state for panning
        let isPanning = false;
        let startPanX = 0;
        let startPanY = 0;

        // Zoom limits
        const MIN_SCALE = 0.01;
        const MAX_SCALE = Number.POSITIVE_INFINITY;

        function handleZoom(event) {
          event.preventDefault();

          const zoomFactor = 0.1; // Zoom speed
          const mouseX = event.offsetX; // Mouse X position relative to the canvas
          const mouseY = event.offsetY; // Mouse Y position relative to the canvas

          // Calculate the new scale
          const oldScale = viewport.scale;
          const newScale =
            event.deltaY < 0
              ? viewport.scale * (1 + zoomFactor) // Zoom in
              : viewport.scale * (1 - zoomFactor); // Zoom out

          // Clamp the scale within limits
          viewport.scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));

          // Adjust the viewport offset to keep the mouse position fixed
          viewport.x =
            mouseX - (mouseX - viewport.x) * (viewport.scale / oldScale);
          viewport.y =
            mouseY - (mouseY - viewport.y) * (viewport.scale / oldScale);

          // Redraw the canvas with the updated viewport
          redraw();
        }
        function startPan(event) {
          // if(event.button != 1) return;
          isPanning = true;
          startPanX = event.offsetX - viewport.x;
          startPanY = event.offsetY - viewport.y;
        }
        function handlePan(event) {
          // if(event.button != 1) return;
          if (isPanning) {
            viewport.x = event.offsetX - startPanX;
            viewport.y = event.offsetY - startPanY;
            redraw();
          }
        }
        function endPan() {
          isPanning = false;
        }

        // Add zoom/pan controls
        canvas.addEventListener("wheel", handleZoom);
        canvas.addEventListener("mousedown", startPan);
        canvas.addEventListener("mousemove", handlePan);
        canvas.addEventListener("mouseup", endPan);
        // Convert screen coordinates to plane coordinates
        function screenToPlaneCoords(screenX, screenY) {
          // Remove viewport translation and scaling
          const planeX = (screenX - viewport.x) / viewport.scale;
          const planeY = (screenY - viewport.y) / viewport.scale;
          return { x: planeX, y: planeY };
        }
        function distance(p1, p2) {
          return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }
        function findClosestPoint(x, y) {
          let closest = db_points[0];
          let minDist = distance(
            { x, y },
            data.tracks[closest.trackIndex].blocks[closest.blockIndex].geometry[
              closest.pointIndex
            ]
          );

          for (const point of db_points) {
            const dist = distance(
              { x, y },
              data.tracks[point.trackIndex].blocks[point.blockIndex].geometry[
                point.pointIndex
              ]
            );
            if (dist < minDist) {
              minDist = dist;
              closest = point;
            }
          }
          return closest;
        }

        canvas.addEventListener("auxclick", (ev) => {
          if (ev.button != 1) return;
          ev.preventDefault();

          // Convert screen coordinates to plane coordinates
          const planeCoords = screenToPlaneCoords(ev.offsetX, ev.offsetY);
          planeCoords.x /= scaleFactor;
          planeCoords.y /= scaleFactor;

          console.log(planeCoords);

          // Find closest point
          const closest = findClosestPoint(planeCoords.x, planeCoords.y);

          if (selected_db.length >= 2) selected_db = [];
          selected_db.push({
            t: closest.trackIndex,
            b: closest.blockIndex,
            p: closest.pointIndex,
          });

          redraw();
        });

        // Add redraw trigger
        function redraw() {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.translate(viewport.x, viewport.y);
          ctx.scale(viewport.scale, viewport.scale);

          data.tracks[11].blocks[0].geometry[0].x = 393.0029139518738;

          renderTracks(data);
          window.data = data;
        }

        // Initial render
        redraw();
      }
      main();
    </script>
  </body>
</html>
