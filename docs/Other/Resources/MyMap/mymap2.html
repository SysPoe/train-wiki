<!DOCTYPE html>
<html>
  <head>
    <title>Track Layout Renderer</title>
    <style>
      body {
        width: 100vw;
        height: 100vh;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: black;
      }
    </style>
  </head>
  <body>
    <canvas id="railCanvas"></canvas>

    <script>
      const sampleDataB = {
        metadata: {
          version: "1.0",
          coordinateSystem: "cartesian2D",
          scale: 1.0,
        },
        tracks: [
          {
            id: "T1",
            name: "Main Line",
            blocks: [
              {
                blockId: "B1",
                geometry: [
                  { x: 0, y: 0 },
                  { x: 0, y: 500 },
                  { x: 500, y: 500 },
                ],
              },
              {
                blockId: "B2",
                geometry: [
                  { x: 500, y: 500 },
                  { x: 1000, y: 500 },
                ],
              },
            ],
          },
        ],
      };

      async function main() {
        let res = await fetch("data.json");
        let sampleData = await res.json();

        sampleData.tracks = sampleData.tracks.reverse();

        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById("railCanvas");
        canvas.width = document.body.getBoundingClientRect().width;
        canvas.height = document.body.getBoundingClientRect().width;
        /** @type {CanvasRenderingContext2D} */
        const ctx = canvas.getContext("2d");

        function renderTracks(data) {
          const scaleFactor = 0.6; // Adjust based on your coordinate scale

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          // ctx.fillStyle = "#000";
          // ctx.fillRect(0, 0, canvas.width, canvas.height);

          data.tracks.forEach((track, trackIndex) => {
            let prevX = Number.NEGATIVE_INFINITY;
            let prevY = Number.NEGATIVE_INFINITY;

            track.blocks.forEach((block) => {
              ctx.beginPath();
              // ctx.strokeStyle = `hsl(${trackIndex * 30}, 100%, 50%)`; // Different color per track
              ctx.strokeStyle = "#FF0000";
              if (/^[A-Z]{3}_P\d+$/.test(block.blockId))
                ctx.strokeStyle = "#0000FF";
              ctx.lineWidth = 4;
              block.geometry[0].x -= 0.01;

              block.geometry.forEach((point, pointIndex) => {
                if (
                  (Math.abs(point.y - prevY) >= 0.01 &&
                    Math.abs(point.y - prevY) / Math.abs(point.x - prevX) <=
                      0.3) ||
                  Math.abs(point.y - prevY) <= 2
                )
                  point.y = prevY;
                if (
                  (Math.abs(point.x - prevX) >= 0.01 &&
                    Math.abs(point.x - prevX) / Math.abs(point.y - prevY) <=
                      0.3) ||
                  Math.abs(point.x - prevX) <= 2
                )
                  point.x = prevX;
                prevY = point.y;
                prevX = point.x;
                
                const x = point.x * scaleFactor;
                const y = point.y * scaleFactor;

                if (pointIndex === 0) {
                  ctx.moveTo(x, y);
                } else {
                  ctx.lineTo(x, y);
                }
              });

              ctx.stroke();
            });
          });

          data.tracks.forEach((v) => {
            let prevX = Number.NEGATIVE_INFINITY;
            let prevY = Number.NEGATIVE_INFINITY;

            v.blocks.forEach((block) => {
              // Draw block ID labels
              const firstPoint = block.geometry[0];
              ctx.fillStyle = "#FFF";
              ctx.font = "8px Arial";
              ctx.fillText(
                block.blockId,
                firstPoint.x * scaleFactor + 5,
                firstPoint.y * scaleFactor + 2
              );
            });
          });
        }

        // Add viewport transformations
        let viewport = {
          x: 0,
          y: 0,
          scale: 1,
        };

        // Mouse state for panning
        let isPanning = false;
        let startPanX = 0;
        let startPanY = 0;

        // Zoom limits
        const MIN_SCALE = 0.01;
        const MAX_SCALE = Number.POSITIVE_INFINITY;

        function handleZoom(event) {
          event.preventDefault();

          const zoomFactor = 0.1; // Zoom speed
          const mouseX = event.offsetX; // Mouse X position relative to the canvas
          const mouseY = event.offsetY; // Mouse Y position relative to the canvas

          // Calculate the new scale
          const oldScale = viewport.scale;
          const newScale =
            event.deltaY < 0
              ? viewport.scale * (1 + zoomFactor) // Zoom in
              : viewport.scale * (1 - zoomFactor); // Zoom out

          // Clamp the scale within limits
          viewport.scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));

          // Adjust the viewport offset to keep the mouse position fixed
          viewport.x =
            mouseX - (mouseX - viewport.x) * (viewport.scale / oldScale);
          viewport.y =
            mouseY - (mouseY - viewport.y) * (viewport.scale / oldScale);

          // Redraw the canvas with the updated viewport
          redraw();
        }

        // Start panning (mouse down)
        function startPan(event) {
          isPanning = true;
          startPanX = event.offsetX - viewport.x;
          startPanY = event.offsetY - viewport.y;
        }

        // Handle panning (mouse move)
        function handlePan(event) {
          if (isPanning) {
            viewport.x = event.offsetX - startPanX;
            viewport.y = event.offsetY - startPanY;
            redraw();
          }
        }

        // End panning (mouse up)

        function endPan() {
          isPanning = false;
        }

        // Add zoom/pan controls
        canvas.addEventListener("wheel", handleZoom);
        canvas.addEventListener("mousedown", startPan);
        canvas.addEventListener("mousemove", handlePan);
        canvas.addEventListener("mouseup", endPan);

        // Add redraw trigger
        function redraw() {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.translate(viewport.x, viewport.y);
          ctx.scale(viewport.scale, viewport.scale);
          renderTracks(sampleData);
        }

        // Initial render
        renderTracks(sampleData);
      }
      main();
    </script>
  </body>
</html>
